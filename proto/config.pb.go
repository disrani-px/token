// Code generated by protoc-gen-go. DO NOT EDIT.
// source: config.proto

/*
Package proto is a generated protocol buffer package.

It is generated from these files:
	config.proto

It has these top-level messages:
	Data
	JobID
	Empty
	Ack
*/
package proto

import proto1 "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto1.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto1.ProtoPackageIsVersion2 // please upgrade the proto package

// server sends data to clients
// this data contains a key that server uses to track a job
type Data struct {
	Tokens []string `protobuf:"bytes,1,rep,name=tokens" json:"tokens,omitempty"`
	Key    string   `protobuf:"bytes,2,opt,name=key" json:"key,omitempty"`
}

func (m *Data) Reset()                    { *m = Data{} }
func (m *Data) String() string            { return proto1.CompactTextString(m) }
func (*Data) ProtoMessage()               {}
func (*Data) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Data) GetTokens() []string {
	if m != nil {
		return m.Tokens
	}
	return nil
}

func (m *Data) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

// client sends jobID to server to request list of tokens to work on
// client requests up to batch_size number of tokens but may receive less
type JobID struct {
	ID        string `protobuf:"bytes,1,opt,name=ID" json:"ID,omitempty"`
	Key       string `protobuf:"bytes,2,opt,name=key" json:"key,omitempty"`
	BatchSize int32  `protobuf:"varint,3,opt,name=batch_size,json=batchSize" json:"batch_size,omitempty"`
}

func (m *JobID) Reset()                    { *m = JobID{} }
func (m *JobID) String() string            { return proto1.CompactTextString(m) }
func (*JobID) ProtoMessage()               {}
func (*JobID) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *JobID) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *JobID) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *JobID) GetBatchSize() int32 {
	if m != nil {
		return m.BatchSize
	}
	return 0
}

// empty is like null, but don't substitute nil pointer for it
type Empty struct {
}

func (m *Empty) Reset()                    { *m = Empty{} }
func (m *Empty) String() string            { return proto1.CompactTextString(m) }
func (*Empty) ProtoMessage()               {}
func (*Empty) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

// server sends acknowledgement for a variety of client calls
type Ack struct {
	N      int32 `protobuf:"varint,1,opt,name=n" json:"n,omitempty"`
	Status bool  `protobuf:"varint,2,opt,name=status" json:"status,omitempty"`
}

func (m *Ack) Reset()                    { *m = Ack{} }
func (m *Ack) String() string            { return proto1.CompactTextString(m) }
func (*Ack) ProtoMessage()               {}
func (*Ack) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Ack) GetN() int32 {
	if m != nil {
		return m.N
	}
	return 0
}

func (m *Ack) GetStatus() bool {
	if m != nil {
		return m.Status
	}
	return false
}

func init() {
	proto1.RegisterType((*Data)(nil), "proto.Data")
	proto1.RegisterType((*JobID)(nil), "proto.JobID")
	proto1.RegisterType((*Empty)(nil), "proto.Empty")
	proto1.RegisterType((*Ack)(nil), "proto.Ack")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Tokens service

type TokensClient interface {
	// client initiates Get() to request a list of tokens
	Get(ctx context.Context, in *JobID, opts ...grpc.CallOption) (*Data, error)
	// client calls Done() acknowledging that the job is done
	Done(ctx context.Context, in *JobID, opts ...grpc.CallOption) (*Ack, error)
	// client calls Reset() to reinit the server meta-data and book keeping state
	Reset(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Ack, error)
	// client requests server to Rescan() the folder to repopulate list of tokens
	Rescan(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Ack, error)
	// client requests server to shuffle the token list
	Shuffle(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Ack, error)
	// client requests server the spit out list of tokens regardless of jobID and other meta-data
	Show(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Data, error)
	// client requests job que status
	HeartBeat(ctx context.Context, in *JobID, opts ...grpc.CallOption) (*Ack, error)
}

type tokensClient struct {
	cc *grpc.ClientConn
}

func NewTokensClient(cc *grpc.ClientConn) TokensClient {
	return &tokensClient{cc}
}

func (c *tokensClient) Get(ctx context.Context, in *JobID, opts ...grpc.CallOption) (*Data, error) {
	out := new(Data)
	err := grpc.Invoke(ctx, "/proto.Tokens/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tokensClient) Done(ctx context.Context, in *JobID, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/proto.Tokens/Done", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tokensClient) Reset(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/proto.Tokens/Reset", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tokensClient) Rescan(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/proto.Tokens/Rescan", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tokensClient) Shuffle(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/proto.Tokens/Shuffle", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tokensClient) Show(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Data, error) {
	out := new(Data)
	err := grpc.Invoke(ctx, "/proto.Tokens/Show", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tokensClient) HeartBeat(ctx context.Context, in *JobID, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/proto.Tokens/HeartBeat", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Tokens service

type TokensServer interface {
	// client initiates Get() to request a list of tokens
	Get(context.Context, *JobID) (*Data, error)
	// client calls Done() acknowledging that the job is done
	Done(context.Context, *JobID) (*Ack, error)
	// client calls Reset() to reinit the server meta-data and book keeping state
	Reset(context.Context, *Empty) (*Ack, error)
	// client requests server to Rescan() the folder to repopulate list of tokens
	Rescan(context.Context, *Empty) (*Ack, error)
	// client requests server to shuffle the token list
	Shuffle(context.Context, *Empty) (*Ack, error)
	// client requests server the spit out list of tokens regardless of jobID and other meta-data
	Show(context.Context, *Empty) (*Data, error)
	// client requests job que status
	HeartBeat(context.Context, *JobID) (*Ack, error)
}

func RegisterTokensServer(s *grpc.Server, srv TokensServer) {
	s.RegisterService(&_Tokens_serviceDesc, srv)
}

func _Tokens_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TokensServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Tokens/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TokensServer).Get(ctx, req.(*JobID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tokens_Done_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TokensServer).Done(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Tokens/Done",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TokensServer).Done(ctx, req.(*JobID))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tokens_Reset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TokensServer).Reset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Tokens/Reset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TokensServer).Reset(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tokens_Rescan_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TokensServer).Rescan(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Tokens/Rescan",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TokensServer).Rescan(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tokens_Shuffle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TokensServer).Shuffle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Tokens/Shuffle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TokensServer).Shuffle(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tokens_Show_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TokensServer).Show(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Tokens/Show",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TokensServer).Show(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tokens_HeartBeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TokensServer).HeartBeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.Tokens/HeartBeat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TokensServer).HeartBeat(ctx, req.(*JobID))
	}
	return interceptor(ctx, in, info, handler)
}

var _Tokens_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.Tokens",
	HandlerType: (*TokensServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _Tokens_Get_Handler,
		},
		{
			MethodName: "Done",
			Handler:    _Tokens_Done_Handler,
		},
		{
			MethodName: "Reset",
			Handler:    _Tokens_Reset_Handler,
		},
		{
			MethodName: "Rescan",
			Handler:    _Tokens_Rescan_Handler,
		},
		{
			MethodName: "Shuffle",
			Handler:    _Tokens_Shuffle_Handler,
		},
		{
			MethodName: "Show",
			Handler:    _Tokens_Show_Handler,
		},
		{
			MethodName: "HeartBeat",
			Handler:    _Tokens_HeartBeat_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "config.proto",
}

func init() { proto1.RegisterFile("config.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 276 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x8f, 0xd1, 0x4a, 0xc3, 0x30,
	0x14, 0x40, 0x97, 0x76, 0xe9, 0xec, 0x75, 0x88, 0xe4, 0x41, 0x8a, 0x20, 0x94, 0x4c, 0xb1, 0x20,
	0x0c, 0xd1, 0x2f, 0x98, 0x54, 0x5c, 0x7d, 0x4c, 0x7d, 0x97, 0xb4, 0xdc, 0xda, 0x52, 0x4d, 0xc6,
	0x92, 0x21, 0xdb, 0x57, 0xf8, 0xc9, 0xd2, 0xac, 0x0f, 0x52, 0xa1, 0x4f, 0xc9, 0x49, 0x0e, 0x97,
	0x73, 0x61, 0x5e, 0x6a, 0x55, 0x35, 0x1f, 0xcb, 0xcd, 0x56, 0x5b, 0xcd, 0xa8, 0x3b, 0xf8, 0x3d,
	0x4c, 0x53, 0x69, 0x25, 0xbb, 0x80, 0xc0, 0xea, 0x16, 0x95, 0x89, 0x48, 0xec, 0x27, 0xa1, 0xe8,
	0x89, 0x9d, 0x83, 0xdf, 0xe2, 0x3e, 0xf2, 0x62, 0x92, 0x84, 0xa2, 0xbb, 0xf2, 0x35, 0xd0, 0x57,
	0x5d, 0x64, 0x29, 0x3b, 0x03, 0x2f, 0x4b, 0x23, 0xe2, 0x7e, 0xbc, 0x2c, 0xfd, 0xaf, 0xb2, 0x2b,
	0x80, 0x42, 0xda, 0xb2, 0x7e, 0x37, 0xcd, 0x01, 0x23, 0x3f, 0x26, 0x09, 0x15, 0xa1, 0x7b, 0xc9,
	0x9b, 0x03, 0xf2, 0x19, 0xd0, 0xe7, 0xaf, 0x8d, 0xdd, 0xf3, 0x3b, 0xf0, 0x57, 0x65, 0xcb, 0xe6,
	0x40, 0x94, 0x9b, 0x47, 0x05, 0x51, 0x5d, 0x91, 0xb1, 0xd2, 0xee, 0x8c, 0x9b, 0x78, 0x22, 0x7a,
	0x7a, 0xf8, 0xf1, 0x20, 0x78, 0x3b, 0xc6, 0x71, 0xf0, 0x5f, 0xd0, 0xb2, 0xf9, 0x71, 0xa5, 0xa5,
	0xcb, 0xba, 0x3c, 0xed, 0xa9, 0x5b, 0x8b, 0x4f, 0x18, 0x87, 0x69, 0xaa, 0x15, 0x0e, 0x24, 0xe8,
	0x69, 0x55, 0xb6, 0x7c, 0xc2, 0x16, 0x40, 0x05, 0x9a, 0x3f, 0x93, 0x5c, 0xd6, 0x40, 0xba, 0x86,
	0x40, 0xa0, 0x29, 0xa5, 0x1a, 0xb5, 0x6e, 0x60, 0x96, 0xd7, 0xbb, 0xaa, 0xfa, 0xc4, 0x51, 0x6d,
	0x01, 0xd3, 0xbc, 0xd6, 0xdf, 0x03, 0x67, 0x90, 0x7e, 0x0b, 0xe1, 0x1a, 0xe5, 0xd6, 0x3e, 0xa1,
	0xb4, 0x63, 0xfd, 0x45, 0xe0, 0xe0, 0xf1, 0x37, 0x00, 0x00, 0xff, 0xff, 0x59, 0x43, 0x8a, 0x4f,
	0xe2, 0x01, 0x00, 0x00,
}
